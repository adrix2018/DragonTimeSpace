// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: msg_enum.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_msg_5fenum_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_msg_5fenum_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_msg_5fenum_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_msg_5fenum_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[2]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_msg_5fenum_2eproto;
namespace msg {
class EntryIDType;
class EntryIDTypeDefaultTypeInternal;
extern EntryIDTypeDefaultTypeInternal _EntryIDType_default_instance_;
class Position;
class PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
}  // namespace msg
PROTOBUF_NAMESPACE_OPEN
template<> ::msg::EntryIDType* Arena::CreateMaybeMessage<::msg::EntryIDType>(Arena*);
template<> ::msg::Position* Arena::CreateMaybeMessage<::msg::Position>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace msg {

enum MapDataType : int {
  MAP_DATATYPE_USER = 0,
  MAP_DATATYPE_NPC = 1
};
bool MapDataType_IsValid(int value);
constexpr MapDataType MapDataType_MIN = MAP_DATATYPE_USER;
constexpr MapDataType MapDataType_MAX = MAP_DATATYPE_NPC;
constexpr int MapDataType_ARRAYSIZE = MapDataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MapDataType_descriptor();
template<typename T>
inline const std::string& MapDataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MapDataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MapDataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MapDataType_descriptor(), enum_t_value);
}
inline bool MapDataType_Parse(
    const std::string& name, MapDataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MapDataType>(
    MapDataType_descriptor(), name, value);
}
enum UserCharbaseState : int {
  CHARBASE_OK = 1,
  CHARBASE_FORBID = 2,
  CHARBASE_FORBID_NAME = 4
};
bool UserCharbaseState_IsValid(int value);
constexpr UserCharbaseState UserCharbaseState_MIN = CHARBASE_OK;
constexpr UserCharbaseState UserCharbaseState_MAX = CHARBASE_FORBID_NAME;
constexpr int UserCharbaseState_ARRAYSIZE = UserCharbaseState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UserCharbaseState_descriptor();
template<typename T>
inline const std::string& UserCharbaseState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UserCharbaseState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UserCharbaseState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UserCharbaseState_descriptor(), enum_t_value);
}
inline bool UserCharbaseState_Parse(
    const std::string& name, UserCharbaseState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UserCharbaseState>(
    UserCharbaseState_descriptor(), name, value);
}
enum LoginRetCode : int {
  LOGIN_RETURN_UNKNOWN = 0,
  LOGIN_RETURN_VERSIONERROR = 1,
  LOGIN_RETURN_UUID = 2,
  LOGIN_RETURN_DB = 3,
  LOGIN_RETURN_PASSWORDERROR = 4,
  LOGIN_RETURN_CHANGEPASSWORD = 5,
  LOGIN_RETURN_IDINUSE = 6,
  LOGIN_RETURN_IDINCLOSE = 7,
  LOGIN_RETURN_GATEWAYNOTAVAILABLE = 8,
  LOGIN_RETURN_USERMAX = 9,
  LOGIN_RETURN_ACCOUNTEXIST = 10,
  LOGIN_RETURN_ACCOUNTSUCCESS = 11,
  LOGIN_RETURN_CHARNAMEREPEAT = 12,
  LOGIN_RETURN_USERDATANOEXIST = 13,
  LOGIN_RETURN_USERNAMEREPEAT = 14,
  LOGIN_RETURN_TIMEOUT = 15,
  LOGIN_RETURN_PAYFAILED = 16,
  LOGIN_RETURN_JPEG_PASSPORT = 17,
  LOGIN_RETURN_LOCK = 18,
  LOGIN_RETURN_WAITACTIVE = 19,
  LOGIN_RETURN_NEWUSER_OLDZONE = 20,
  LOGIN_RETURN_UUID_ERROR = 21,
  LOGIN_RETURN_USER_TOZONE = 22,
  LOGIN_RETURN_CHANGE_LOGIN = 23,
  LOGIN_RETURN_MATRIX_ERROR = 24,
  LOGIN_RETURN_MATRIX_NEED = 25,
  LOGIN_RETURN_MATRIX_LOCK = 26,
  LOGIN_RETURN_MATRIX_DOWN = 27,
  LOGIN_RETURN_OLDUSER_NEWZONE = 28,
  LOGIN_RETURN_IMG_LOCK = 29,
  LOGIN_RETURN_PASSPOD_PASSWORDERROR = 30,
  LOGIN_RETURN_PASSPOD_DOWN = 31,
  LOGIN_RETURN_BUSY = 32,
  LOGIN_RETURN_FORBID = 33,
  LOGIN_RETURN_IMG_LOCK2 = 34,
  LOGIN_RETURN_MAINTAIN = 35,
  LOGIN_RETURN_TDCODE_GEN_ERROR = 36,
  LOGIN_RETURN_TDCODE_DOWN = 37,
  LOGIN_RETURN_TOKEN_ERROR = 38,
  LOGIN_RETURN_TOKEN_TOO_QUICK = 39,
  LOGIN_RETURN_TOKEN_TIMEOUT = 40,
  LOGIN_RETURN_SHOW_MSG = 41,
  LOGIN_RETURN_USERINLOGIN = 42,
  LOGIN_RETURN_CHARNAME_INVALID = 43,
  LOGIN_RETURN_GATEWAY_ID_INVALID = 44,
  LOGIN_RETURN_CHARNAME_LEN_ERR = 45,
  LOGIN_RETURN_ROLEMAX = 46,
  LOGIN_RETURN_ROLE_FORBID = 47
};
bool LoginRetCode_IsValid(int value);
constexpr LoginRetCode LoginRetCode_MIN = LOGIN_RETURN_UNKNOWN;
constexpr LoginRetCode LoginRetCode_MAX = LOGIN_RETURN_ROLE_FORBID;
constexpr int LoginRetCode_ARRAYSIZE = LoginRetCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LoginRetCode_descriptor();
template<typename T>
inline const std::string& LoginRetCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LoginRetCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LoginRetCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LoginRetCode_descriptor(), enum_t_value);
}
inline bool LoginRetCode_Parse(
    const std::string& name, LoginRetCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LoginRetCode>(
    LoginRetCode_descriptor(), name, value);
}
enum Occupation : int {
  Occu_Dema = 1,
  Occu_Yaohu = 2
};
bool Occupation_IsValid(int value);
constexpr Occupation Occupation_MIN = Occu_Dema;
constexpr Occupation Occupation_MAX = Occu_Yaohu;
constexpr int Occupation_ARRAYSIZE = Occupation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Occupation_descriptor();
template<typename T>
inline const std::string& Occupation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Occupation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Occupation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Occupation_descriptor(), enum_t_value);
}
inline bool Occupation_Parse(
    const std::string& name, Occupation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Occupation>(
    Occupation_descriptor(), name, value);
}
enum QuestCrcRet : int {
  CrcRet_Same = 1,
  CrcRet_Diff = 2
};
bool QuestCrcRet_IsValid(int value);
constexpr QuestCrcRet QuestCrcRet_MIN = CrcRet_Same;
constexpr QuestCrcRet QuestCrcRet_MAX = CrcRet_Diff;
constexpr int QuestCrcRet_ARRAYSIZE = QuestCrcRet_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* QuestCrcRet_descriptor();
template<typename T>
inline const std::string& QuestCrcRet_Name(T enum_t_value) {
  static_assert(::std::is_same<T, QuestCrcRet>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function QuestCrcRet_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    QuestCrcRet_descriptor(), enum_t_value);
}
inline bool QuestCrcRet_Parse(
    const std::string& name, QuestCrcRet* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<QuestCrcRet>(
    QuestCrcRet_descriptor(), name, value);
}
enum ZonedefType : int {
  ZONE_NONE = 0,
  ZONE_PK_SAFE = 1,
  ZONE_ABSOLUTE_SAFE = 2,
  ZONE_RELIVE = 4,
  ZONE_NEWBIE = 8,
  ZONE_FOREIGN_RELIVE = 16,
  ZONE_GUILD = 32,
  ZONE_TRANSPORT = 64,
  ZONE_ENTER_COPYMAP = 128,
  ZONE_QUIT_COPYMAP = 256,
  ZONE_PVP_CAMP_RED = 512,
  ZONE_PVP_CAMP_BLUE = 1024,
  ZONE_PVP_COMMIT_RED = 2048,
  ZONE_PVP_COMMIT_BLUE = 4096,
  ZONE_PVP_RELIVE_RED = 8192,
  ZONE_PVP_RELIVE_BLUE = 16384
};
bool ZonedefType_IsValid(int value);
constexpr ZonedefType ZonedefType_MIN = ZONE_NONE;
constexpr ZonedefType ZonedefType_MAX = ZONE_PVP_RELIVE_BLUE;
constexpr int ZonedefType_ARRAYSIZE = ZonedefType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ZonedefType_descriptor();
template<typename T>
inline const std::string& ZonedefType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ZonedefType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ZonedefType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ZonedefType_descriptor(), enum_t_value);
}
inline bool ZonedefType_Parse(
    const std::string& name, ZonedefType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ZonedefType>(
    ZonedefType_descriptor(), name, value);
}
enum ReliveType : int {
  RELIVE_NONE = 0,
  RELIVE_HOME = 1,
  RELIVE_ORIGIN = 2,
  RELIVE_GUILD = 3,
  RELIVE_PKRAND = 4,
  RELIVE_COUNTRY = 5,
  RELIVE_NEAREST = 6,
  RELIVE_BATTLE = 7,
  RELIVE_SKILL = 8
};
bool ReliveType_IsValid(int value);
constexpr ReliveType ReliveType_MIN = RELIVE_NONE;
constexpr ReliveType ReliveType_MAX = RELIVE_SKILL;
constexpr int ReliveType_ARRAYSIZE = ReliveType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ReliveType_descriptor();
template<typename T>
inline const std::string& ReliveType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ReliveType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ReliveType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ReliveType_descriptor(), enum_t_value);
}
inline bool ReliveType_Parse(
    const std::string& name, ReliveType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ReliveType>(
    ReliveType_descriptor(), name, value);
}
enum PKMode : int {
  PKMode_None = 0,
  PKMode_Peace = 1,
  PKMode_Personal = 2,
  PKMode_Guild = 3,
  PKMode_Team = 4,
  PKMode_Normal = 5
};
bool PKMode_IsValid(int value);
constexpr PKMode PKMode_MIN = PKMode_None;
constexpr PKMode PKMode_MAX = PKMode_Normal;
constexpr int PKMode_ARRAYSIZE = PKMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PKMode_descriptor();
template<typename T>
inline const std::string& PKMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PKMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PKMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PKMode_descriptor(), enum_t_value);
}
inline bool PKMode_Parse(
    const std::string& name, PKMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PKMode>(
    PKMode_descriptor(), name, value);
}
enum QuestState : int {
  UNACCEPT = 0,
  DOING = 1,
  ACCEPTABLE = 99,
  FINISHED = 100,
  FINISHED_SAVE = 101,
  FINISHED_NOTSAVE = 102
};
bool QuestState_IsValid(int value);
constexpr QuestState QuestState_MIN = UNACCEPT;
constexpr QuestState QuestState_MAX = FINISHED_NOTSAVE;
constexpr int QuestState_ARRAYSIZE = QuestState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* QuestState_descriptor();
template<typename T>
inline const std::string& QuestState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, QuestState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function QuestState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    QuestState_descriptor(), enum_t_value);
}
inline bool QuestState_Parse(
    const std::string& name, QuestState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<QuestState>(
    QuestState_descriptor(), name, value);
}
enum RefreshType : int {
  RefreshType_None = 0,
  RefreshType_DaxSix = 1,
  RefreshType_MondaySix = 2,
  RefreshType_MonthFirstSix = 3,
  RefreshType_DayMany = 4
};
bool RefreshType_IsValid(int value);
constexpr RefreshType RefreshType_MIN = RefreshType_None;
constexpr RefreshType RefreshType_MAX = RefreshType_DayMany;
constexpr int RefreshType_ARRAYSIZE = RefreshType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RefreshType_descriptor();
template<typename T>
inline const std::string& RefreshType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RefreshType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RefreshType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RefreshType_descriptor(), enum_t_value);
}
inline bool RefreshType_Parse(
    const std::string& name, RefreshType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RefreshType>(
    RefreshType_descriptor(), name, value);
}
enum MATCHFIGHT : int {
  FIGHT_NONE = 0,
  FIGHT_RANKPK = 1,
  FIGHT_TILLDIE = 2,
  FIGHT_RANDOM = 3,
  FIGHT_MAX = 4
};
bool MATCHFIGHT_IsValid(int value);
constexpr MATCHFIGHT MATCHFIGHT_MIN = FIGHT_NONE;
constexpr MATCHFIGHT MATCHFIGHT_MAX = FIGHT_MAX;
constexpr int MATCHFIGHT_ARRAYSIZE = MATCHFIGHT_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MATCHFIGHT_descriptor();
template<typename T>
inline const std::string& MATCHFIGHT_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MATCHFIGHT>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MATCHFIGHT_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MATCHFIGHT_descriptor(), enum_t_value);
}
inline bool MATCHFIGHT_Parse(
    const std::string& name, MATCHFIGHT* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MATCHFIGHT>(
    MATCHFIGHT_descriptor(), name, value);
}
enum StageType : int {
  None_Stage = 0,
  Match = 1,
  Login = 2,
  Prepare = 3,
  PreFight = 4,
  CountDown = 5,
  Fight = 6,
  Speedup = 7,
  Finish = 8,
  Max_Stage = 9
};
bool StageType_IsValid(int value);
constexpr StageType StageType_MIN = None_Stage;
constexpr StageType StageType_MAX = Max_Stage;
constexpr int StageType_ARRAYSIZE = StageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StageType_descriptor();
template<typename T>
inline const std::string& StageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StageType_descriptor(), enum_t_value);
}
inline bool StageType_Parse(
    const std::string& name, StageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StageType>(
    StageType_descriptor(), name, value);
}
enum MATCHFIGHTTEAMMODE : int {
  SOLO = 1,
  TEAM = 2,
  BOTH = 3
};
bool MATCHFIGHTTEAMMODE_IsValid(int value);
constexpr MATCHFIGHTTEAMMODE MATCHFIGHTTEAMMODE_MIN = SOLO;
constexpr MATCHFIGHTTEAMMODE MATCHFIGHTTEAMMODE_MAX = BOTH;
constexpr int MATCHFIGHTTEAMMODE_ARRAYSIZE = MATCHFIGHTTEAMMODE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MATCHFIGHTTEAMMODE_descriptor();
template<typename T>
inline const std::string& MATCHFIGHTTEAMMODE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MATCHFIGHTTEAMMODE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MATCHFIGHTTEAMMODE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MATCHFIGHTTEAMMODE_descriptor(), enum_t_value);
}
inline bool MATCHFIGHTTEAMMODE_Parse(
    const std::string& name, MATCHFIGHTTEAMMODE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MATCHFIGHTTEAMMODE>(
    MATCHFIGHTTEAMMODE_descriptor(), name, value);
}
enum MATCHFIGHTTEAM : int {
  BLUE = 1,
  RED = 2
};
bool MATCHFIGHTTEAM_IsValid(int value);
constexpr MATCHFIGHTTEAM MATCHFIGHTTEAM_MIN = BLUE;
constexpr MATCHFIGHTTEAM MATCHFIGHTTEAM_MAX = RED;
constexpr int MATCHFIGHTTEAM_ARRAYSIZE = MATCHFIGHTTEAM_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MATCHFIGHTTEAM_descriptor();
template<typename T>
inline const std::string& MATCHFIGHTTEAM_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MATCHFIGHTTEAM>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MATCHFIGHTTEAM_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MATCHFIGHTTEAM_descriptor(), enum_t_value);
}
inline bool MATCHFIGHTTEAM_Parse(
    const std::string& name, MATCHFIGHTTEAM* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MATCHFIGHTTEAM>(
    MATCHFIGHTTEAM_descriptor(), name, value);
}
enum FIGHTRESULT : int {
  WIN = 1,
  LOSE = 2
};
bool FIGHTRESULT_IsValid(int value);
constexpr FIGHTRESULT FIGHTRESULT_MIN = WIN;
constexpr FIGHTRESULT FIGHTRESULT_MAX = LOSE;
constexpr int FIGHTRESULT_ARRAYSIZE = FIGHTRESULT_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FIGHTRESULT_descriptor();
template<typename T>
inline const std::string& FIGHTRESULT_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FIGHTRESULT>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FIGHTRESULT_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FIGHTRESULT_descriptor(), enum_t_value);
}
inline bool FIGHTRESULT_Parse(
    const std::string& name, FIGHTRESULT* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FIGHTRESULT>(
    FIGHTRESULT_descriptor(), name, value);
}
enum RISESTAR : int {
  RISESTAR_SUCCESS = 1,
  RISESTAR_THISIDERR = 2,
  RISESTAR_BASEIDERR = 3,
  RISESTAR_MAXSTARERR = 4,
  RISESTAR_LOCKEDERR = 5
};
bool RISESTAR_IsValid(int value);
constexpr RISESTAR RISESTAR_MIN = RISESTAR_SUCCESS;
constexpr RISESTAR RISESTAR_MAX = RISESTAR_LOCKEDERR;
constexpr int RISESTAR_ARRAYSIZE = RISESTAR_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RISESTAR_descriptor();
template<typename T>
inline const std::string& RISESTAR_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RISESTAR>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RISESTAR_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RISESTAR_descriptor(), enum_t_value);
}
inline bool RISESTAR_Parse(
    const std::string& name, RISESTAR* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RISESTAR>(
    RISESTAR_descriptor(), name, value);
}
enum SEX : int {
  NONE = 1,
  MALE = 2,
  FEMALE = 3
};
bool SEX_IsValid(int value);
constexpr SEX SEX_MIN = NONE;
constexpr SEX SEX_MAX = FEMALE;
constexpr int SEX_ARRAYSIZE = SEX_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SEX_descriptor();
template<typename T>
inline const std::string& SEX_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SEX>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SEX_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SEX_descriptor(), enum_t_value);
}
inline bool SEX_Parse(
    const std::string& name, SEX* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SEX>(
    SEX_descriptor(), name, value);
}
enum SELLTYPE : int {
  SELLNONE = 0,
  OBJECT = 1,
  HERO = 2
};
bool SELLTYPE_IsValid(int value);
constexpr SELLTYPE SELLTYPE_MIN = SELLNONE;
constexpr SELLTYPE SELLTYPE_MAX = HERO;
constexpr int SELLTYPE_ARRAYSIZE = SELLTYPE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SELLTYPE_descriptor();
template<typename T>
inline const std::string& SELLTYPE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SELLTYPE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SELLTYPE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SELLTYPE_descriptor(), enum_t_value);
}
inline bool SELLTYPE_Parse(
    const std::string& name, SELLTYPE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SELLTYPE>(
    SELLTYPE_descriptor(), name, value);
}
enum CreateRoleLookType : int {
  CREATE_ROLE_LOOK_TYPE_HAIR_COLOR = 1,
  CREATE_ROLE_LOOK_TYPE_HAIR_STYLE = 2,
  CREATE_ROLE_LOOK_TYPE_FACE_STYLE = 3,
  CREATE_ROLE_LOOK_TYPE_ANTENNA = 4
};
bool CreateRoleLookType_IsValid(int value);
constexpr CreateRoleLookType CreateRoleLookType_MIN = CREATE_ROLE_LOOK_TYPE_HAIR_COLOR;
constexpr CreateRoleLookType CreateRoleLookType_MAX = CREATE_ROLE_LOOK_TYPE_ANTENNA;
constexpr int CreateRoleLookType_ARRAYSIZE = CreateRoleLookType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CreateRoleLookType_descriptor();
template<typename T>
inline const std::string& CreateRoleLookType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CreateRoleLookType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CreateRoleLookType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CreateRoleLookType_descriptor(), enum_t_value);
}
inline bool CreateRoleLookType_Parse(
    const std::string& name, CreateRoleLookType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CreateRoleLookType>(
    CreateRoleLookType_descriptor(), name, value);
}
enum AnswerShareQuestRetCode : int {
  ANSWER_SHARE_QUEST_RET_CODE_SUCCESS = 0,
  ANSWER_SHARE_QUEST_RET_CODE_NOT_EXIST = 1,
  ANSWER_SHARE_QUEST_RET_CODE_LEVEL = 2,
  ANSWER_SHARE_QUEST_RET_CODE_PREQUEST = 3,
  ANSWER_SHARE_QUEST_RET_CODE_DOING = 4,
  ANSWER_SHARE_QUEST_RET_CODE_DAILY_QUEST = 5,
  ANSWER_SHARE_QUEST_RET_CODE_OTHER = 6
};
bool AnswerShareQuestRetCode_IsValid(int value);
constexpr AnswerShareQuestRetCode AnswerShareQuestRetCode_MIN = ANSWER_SHARE_QUEST_RET_CODE_SUCCESS;
constexpr AnswerShareQuestRetCode AnswerShareQuestRetCode_MAX = ANSWER_SHARE_QUEST_RET_CODE_OTHER;
constexpr int AnswerShareQuestRetCode_ARRAYSIZE = AnswerShareQuestRetCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AnswerShareQuestRetCode_descriptor();
template<typename T>
inline const std::string& AnswerShareQuestRetCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AnswerShareQuestRetCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AnswerShareQuestRetCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AnswerShareQuestRetCode_descriptor(), enum_t_value);
}
inline bool AnswerShareQuestRetCode_Parse(
    const std::string& name, AnswerShareQuestRetCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AnswerShareQuestRetCode>(
    AnswerShareQuestRetCode_descriptor(), name, value);
}
enum ERechargeReturnCode : int {
  ERECHARGE_RETURN_CODE_SUCCESS = 0,
  ERECHARGE_RETURN_CODE_SERVICE_LOST = 1,
  ERECHARGE_RETURN_CODE_ACCOUNT_NOT_FOUND = 2,
  ERECHARGE_RETURN_CODE_NOT_ENOUGH = 3,
  ERECHARGE_RETURN_CODE_CARD_NOT_FOUND = 4,
  ERECHARGE_RETURN_CODE_CARD_CAN_NOT_USER = 5,
  ERECHARGE_RETURN_CODE_CARD_CAN_USE_MULTY = 6,
  ERECHARGE_RETURN_CODE_CARD_ERROR_NUMBER = 7,
  ERECHARGE_RETURN_CODE_CARD_ERROR_PSWD = 8,
  ERECHARGE_RETURN_CODE_DATABASE_ERROR = 9,
  ERECHARGE_RETURN_CODE_IN_PROCESSING = 10,
  ERECHARGE_RETURN_CODE_UNKNOWN_ERROR = 11
};
bool ERechargeReturnCode_IsValid(int value);
constexpr ERechargeReturnCode ERechargeReturnCode_MIN = ERECHARGE_RETURN_CODE_SUCCESS;
constexpr ERechargeReturnCode ERechargeReturnCode_MAX = ERECHARGE_RETURN_CODE_UNKNOWN_ERROR;
constexpr int ERechargeReturnCode_ARRAYSIZE = ERechargeReturnCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ERechargeReturnCode_descriptor();
template<typename T>
inline const std::string& ERechargeReturnCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ERechargeReturnCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ERechargeReturnCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ERechargeReturnCode_descriptor(), enum_t_value);
}
inline bool ERechargeReturnCode_Parse(
    const std::string& name, ERechargeReturnCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ERechargeReturnCode>(
    ERechargeReturnCode_descriptor(), name, value);
}
// ===================================================================

class EntryIDType :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.EntryIDType) */ {
 public:
  EntryIDType();
  virtual ~EntryIDType();

  EntryIDType(const EntryIDType& from);
  EntryIDType(EntryIDType&& from) noexcept
    : EntryIDType() {
    *this = ::std::move(from);
  }

  inline EntryIDType& operator=(const EntryIDType& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntryIDType& operator=(EntryIDType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EntryIDType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntryIDType* internal_default_instance() {
    return reinterpret_cast<const EntryIDType*>(
               &_EntryIDType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(EntryIDType& a, EntryIDType& b) {
    a.Swap(&b);
  }
  inline void Swap(EntryIDType* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EntryIDType* New() const final {
    return CreateMaybeMessage<EntryIDType>(nullptr);
  }

  EntryIDType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EntryIDType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EntryIDType& from);
  void MergeFrom(const EntryIDType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EntryIDType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.EntryIDType";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_msg_5fenum_2eproto);
    return ::descriptor_table_msg_5fenum_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // optional uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint32 type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::uint32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:msg.EntryIDType)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 type_;
  friend struct ::TableStruct_msg_5fenum_2eproto;
};
// -------------------------------------------------------------------

class Position :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.Position) */ {
 public:
  Position();
  virtual ~Position();

  Position(const Position& from);
  Position(Position&& from) noexcept
    : Position() {
    *this = ::std::move(from);
  }

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  inline Position& operator=(Position&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Position& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
               &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Position& a, Position& b) {
    a.Swap(&b);
  }
  inline void Swap(Position* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Position* New() const final {
    return CreateMaybeMessage<Position>(nullptr);
  }

  Position* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Position>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Position* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.Position";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_msg_5fenum_2eproto);
    return ::descriptor_table_msg_5fenum_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // optional float x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // optional float y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:msg.Position)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  friend struct ::TableStruct_msg_5fenum_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EntryIDType

// optional uint64 id = 1;
inline bool EntryIDType::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EntryIDType::has_id() const {
  return _internal_has_id();
}
inline void EntryIDType::clear_id() {
  id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 EntryIDType::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 EntryIDType::id() const {
  // @@protoc_insertion_point(field_get:msg.EntryIDType.id)
  return _internal_id();
}
inline void EntryIDType::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  id_ = value;
}
inline void EntryIDType::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:msg.EntryIDType.id)
}

// optional uint32 type = 2;
inline bool EntryIDType::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EntryIDType::has_type() const {
  return _internal_has_type();
}
inline void EntryIDType::clear_type() {
  type_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 EntryIDType::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 EntryIDType::type() const {
  // @@protoc_insertion_point(field_get:msg.EntryIDType.type)
  return _internal_type();
}
inline void EntryIDType::_internal_set_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void EntryIDType::set_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:msg.EntryIDType.type)
}

// -------------------------------------------------------------------

// Position

// optional float x = 1;
inline bool Position::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Position::has_x() const {
  return _internal_has_x();
}
inline void Position::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float Position::_internal_x() const {
  return x_;
}
inline float Position::x() const {
  // @@protoc_insertion_point(field_get:msg.Position.x)
  return _internal_x();
}
inline void Position::_internal_set_x(float value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void Position::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:msg.Position.x)
}

// optional float y = 2;
inline bool Position::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Position::has_y() const {
  return _internal_has_y();
}
inline void Position::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Position::_internal_y() const {
  return y_;
}
inline float Position::y() const {
  // @@protoc_insertion_point(field_get:msg.Position.y)
  return _internal_y();
}
inline void Position::_internal_set_y(float value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void Position::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:msg.Position.y)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace msg

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::msg::MapDataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::msg::MapDataType>() {
  return ::msg::MapDataType_descriptor();
}
template <> struct is_proto_enum< ::msg::UserCharbaseState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::msg::UserCharbaseState>() {
  return ::msg::UserCharbaseState_descriptor();
}
template <> struct is_proto_enum< ::msg::LoginRetCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::msg::LoginRetCode>() {
  return ::msg::LoginRetCode_descriptor();
}
template <> struct is_proto_enum< ::msg::Occupation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::msg::Occupation>() {
  return ::msg::Occupation_descriptor();
}
template <> struct is_proto_enum< ::msg::QuestCrcRet> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::msg::QuestCrcRet>() {
  return ::msg::QuestCrcRet_descriptor();
}
template <> struct is_proto_enum< ::msg::ZonedefType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::msg::ZonedefType>() {
  return ::msg::ZonedefType_descriptor();
}
template <> struct is_proto_enum< ::msg::ReliveType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::msg::ReliveType>() {
  return ::msg::ReliveType_descriptor();
}
template <> struct is_proto_enum< ::msg::PKMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::msg::PKMode>() {
  return ::msg::PKMode_descriptor();
}
template <> struct is_proto_enum< ::msg::QuestState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::msg::QuestState>() {
  return ::msg::QuestState_descriptor();
}
template <> struct is_proto_enum< ::msg::RefreshType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::msg::RefreshType>() {
  return ::msg::RefreshType_descriptor();
}
template <> struct is_proto_enum< ::msg::MATCHFIGHT> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::msg::MATCHFIGHT>() {
  return ::msg::MATCHFIGHT_descriptor();
}
template <> struct is_proto_enum< ::msg::StageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::msg::StageType>() {
  return ::msg::StageType_descriptor();
}
template <> struct is_proto_enum< ::msg::MATCHFIGHTTEAMMODE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::msg::MATCHFIGHTTEAMMODE>() {
  return ::msg::MATCHFIGHTTEAMMODE_descriptor();
}
template <> struct is_proto_enum< ::msg::MATCHFIGHTTEAM> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::msg::MATCHFIGHTTEAM>() {
  return ::msg::MATCHFIGHTTEAM_descriptor();
}
template <> struct is_proto_enum< ::msg::FIGHTRESULT> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::msg::FIGHTRESULT>() {
  return ::msg::FIGHTRESULT_descriptor();
}
template <> struct is_proto_enum< ::msg::RISESTAR> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::msg::RISESTAR>() {
  return ::msg::RISESTAR_descriptor();
}
template <> struct is_proto_enum< ::msg::SEX> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::msg::SEX>() {
  return ::msg::SEX_descriptor();
}
template <> struct is_proto_enum< ::msg::SELLTYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::msg::SELLTYPE>() {
  return ::msg::SELLTYPE_descriptor();
}
template <> struct is_proto_enum< ::msg::CreateRoleLookType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::msg::CreateRoleLookType>() {
  return ::msg::CreateRoleLookType_descriptor();
}
template <> struct is_proto_enum< ::msg::AnswerShareQuestRetCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::msg::AnswerShareQuestRetCode>() {
  return ::msg::AnswerShareQuestRetCode_descriptor();
}
template <> struct is_proto_enum< ::msg::ERechargeReturnCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::msg::ERechargeReturnCode>() {
  return ::msg::ERechargeReturnCode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_msg_5fenum_2eproto
